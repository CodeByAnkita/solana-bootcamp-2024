import { ComputeBudgetProgram } from "@solana/web3.js";
import { TransactionMessage, VersionedTransaction } from "@solana/web3.js";
export class InstructionUtils {
    static async asV0TxWithComputeIxs(params) {
        let payer = params.payer;
        if (payer === undefined && (params.signers ?? []).length === 0) {
            throw new Error("Payer not provided");
        }
        if (payer === undefined) {
            payer = params.signers[0].publicKey;
        }
        const priorityFeeIx = ComputeBudgetProgram.setComputeUnitPrice({
            microLamports: params.computeUnitPrice ?? 0,
        });
        const simulationComputeLimitIx = ComputeBudgetProgram.setComputeUnitLimit({
            units: 1_400_000,
        });
        const recentBlockhash = (await params.connection.getLatestBlockhash())
            .blockhash;
        const simulateMessageV0 = new TransactionMessage({
            recentBlockhash,
            instructions: [priorityFeeIx, simulationComputeLimitIx, ...params.ixs],
            payerKey: payer,
        }).compileToV0Message(params.lookupTables ?? []);
        const simulationResult = await params.connection.simulateTransaction(new VersionedTransaction(simulateMessageV0), {
            commitment: "processed",
            sigVerify: false,
        });
        const simulationUnitsConsumed = simulationResult.value.unitsConsumed;
        const computeLimitIx = ComputeBudgetProgram.setComputeUnitLimit({
            units: Math.floor(simulationUnitsConsumed * (params.computeUnitLimitMultiple ?? 1)),
        });
        const messageV0 = new TransactionMessage({
            recentBlockhash,
            instructions: [priorityFeeIx, computeLimitIx, ...params.ixs],
            payerKey: payer,
        }).compileToV0Message(params.lookupTables ?? []);
        const tx = new VersionedTransaction(messageV0);
        tx.sign(params.signers ?? []);
        return tx;
    }
}
//# sourceMappingURL=InstructionUtils.js.map