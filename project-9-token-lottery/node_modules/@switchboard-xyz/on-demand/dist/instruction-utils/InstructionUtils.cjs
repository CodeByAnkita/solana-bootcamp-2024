"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InstructionUtils = void 0;
const web3_js_1 = require("@solana/web3.js");
const web3_js_2 = require("@solana/web3.js");
class InstructionUtils {
    static async asV0TxWithComputeIxs(params) {
        let payer = params.payer;
        if (payer === undefined && (params.signers ?? []).length === 0) {
            throw new Error("Payer not provided");
        }
        if (payer === undefined) {
            payer = params.signers[0].publicKey;
        }
        const priorityFeeIx = web3_js_1.ComputeBudgetProgram.setComputeUnitPrice({
            microLamports: params.computeUnitPrice ?? 0,
        });
        const simulationComputeLimitIx = web3_js_1.ComputeBudgetProgram.setComputeUnitLimit({
            units: 1_400_000,
        });
        const recentBlockhash = (await params.connection.getLatestBlockhash())
            .blockhash;
        const simulateMessageV0 = new web3_js_2.TransactionMessage({
            recentBlockhash,
            instructions: [priorityFeeIx, simulationComputeLimitIx, ...params.ixs],
            payerKey: payer,
        }).compileToV0Message(params.lookupTables ?? []);
        const simulationResult = await params.connection.simulateTransaction(new web3_js_2.VersionedTransaction(simulateMessageV0), {
            commitment: "processed",
            sigVerify: false,
        });
        const simulationUnitsConsumed = simulationResult.value.unitsConsumed;
        const computeLimitIx = web3_js_1.ComputeBudgetProgram.setComputeUnitLimit({
            units: Math.floor(simulationUnitsConsumed * (params.computeUnitLimitMultiple ?? 1)),
        });
        const messageV0 = new web3_js_2.TransactionMessage({
            recentBlockhash,
            instructions: [priorityFeeIx, computeLimitIx, ...params.ixs],
            payerKey: payer,
        }).compileToV0Message(params.lookupTables ?? []);
        const tx = new web3_js_2.VersionedTransaction(messageV0);
        tx.sign(params.signers ?? []);
        return tx;
    }
}
exports.InstructionUtils = InstructionUtils;
//# sourceMappingURL=InstructionUtils.js.map