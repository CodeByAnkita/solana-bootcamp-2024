import { OracleJob } from "@switchboard-xyz/common";
import axios from "axios";
import * as bs58 from "bs58";
import { Agent as HttpsAgent } from "https";
import NodeCache from "node-cache";
const GATEWAY_PING_CACHE = new NodeCache({ stdTTL: 100, checkperiod: 120 });
function newAbortSignal(timeoutMs) {
    const abortController = new AbortController();
    setTimeout(() => abortController.abort(), timeoutMs);
    return abortController.signal;
}
const httpsAgent = new HttpsAgent({
    rejectUnauthorized: false,
});
const timeout = 10_000;
function axiosClient() {
    return axios.create({
        httpsAgent,
        signal: newAbortSignal(timeout),
    });
}
function encodeJobs(jobArray) {
    return jobArray.map((job) => Buffer.from(OracleJob.encodeDelimited(job).finish()).toString("base64"));
}
export class Gateway {
    program;
    gatewayUrl;
    oracleKey;
    constructor(program, gatewayUrl, oracleKey) {
        this.program = program;
        this.gatewayUrl = gatewayUrl;
        this.oracleKey = oracleKey;
    }
    async fetchSignaturesFromEncoded(params) {
        const { recentHash, encodedJobs, numSignatures } = params;
        const url = `${this.gatewayUrl}/gateway/api/v1/fetch_signatures`;
        const method = "POST";
        const headers = { "Content-Type": "application/json" };
        const maxVariance = Math.floor((params.maxVariance ?? 1) * 1e9);
        const body = JSON.stringify({
            api_version: "1.0.0",
            jobs_b64_encoded: encodedJobs,
            recent_chainhash: recentHash ?? bs58.encode(Buffer.alloc(32, 0)),
            signature_scheme: "Secp256k1",
            hash_scheme: "Sha256",
            num_oracles: numSignatures,
            max_variance: maxVariance,
            min_responses: params.minResponses,
            use_timestamp: params.useTimestamp ?? false,
        });
        return axiosClient()(url, { method, headers, data: body })
            .then((r) => r.data)
            .then((r) => r.responses);
    }
    async ping() {
        const url = `${this.gatewayUrl}/gateway/api/v1/ping`;
        const method = "POST";
        const headers = { "Content-Type": "application/json" };
        const body = JSON.stringify({ api_version: "1.0.0" });
        return fetch(url, { method, headers, body }).then((r) => r.json());
    }
    async fetchAttestation(params) {
        const api_version = "1.0.0";
        const url = `${this.gatewayUrl}/gateway/api/v1/gateway_attest_enclave`;
        const method = "POST";
        const headers = { "Content-Type": "application/json" };
        const body = JSON.stringify({
            api_version,
            timestamp: params.timestamp,
            quote: params.quote,
            oracle_pubkey: params.oracle_pubkey,
            oracle_reward_wallet: params.oracle_reward_wallet,
            oracle_ed25519_enclave_signer: params.oracle_ed25519_enclave_signer,
            oracle_secp256k1_enclave_signer: params.oracle_secp256k1_enclave_signer,
            chain_hash: params.recentHash,
        });
        return fetch(url, { method, headers, body }).then((r) => r.json());
    }
    async fetchQuote(params) {
        const api_version = "1.0.0";
        const url = `${this.endpoint()}/gateway/api/v1/gateway_fetch_quote`;
        const method = "POST";
        const headers = { "Content-Type": "application/json" };
        const body = JSON.stringify({
            api_version,
            blockhash: params.blockhash,
            get_for_oracle: params.get_for_oracle,
            get_for_guardian: params.get_for_guardian,
        });
        return fetch(url, { method, headers, body }).then(async (r) => {
            return r.json();
        });
    }
    async fetchBridgingMessage(params) {
        const api_version = "1.0.0";
        const url = `${this.gatewayUrl}/gateway/api/v1/gateway_bridge_enclave`;
        const method = "POST";
        const headers = { "Content-Type": "application/json" };
        const body = JSON.stringify({
            api_version,
            chain_hash: params.chainHash,
            oracle_pubkey: params.oraclePubkey,
            queue_pubkey: params.queuePubkey,
        });
        return fetch(url, { method, headers, body }).then(async (r) => {
            if (!r.ok) {
                throw new Error(`Request failed with status ${r.status}`);
            }
            return r.json();
        });
    }
    async fetchSignatures(params) {
        params.numSignatures = params.numSignatures ?? 1;
        params.maxVariance = params.maxVariance ?? 1;
        params.minResponses = params.minResponses ?? 1;
        const { recentHash, jobs, numSignatures, maxVariance, minResponses, useTimestamp, } = params;
        const encodedJobs = encodeJobs(jobs);
        const res = await this.fetchSignaturesFromEncoded({
            recentHash,
            encodedJobs,
            numSignatures,
            maxVariance,
            minResponses,
            useTimestamp,
        });
        return res;
    }
    async fetchSignaturesMulti(params) {
        const { recentHash, feedConfigs, useTimestamp, numSignatures } = params;
        const encodedConfigs = feedConfigs.map((config) => {
            const encodedJobs = encodeJobs(config.jobs);
            return {
                encodedJobs,
                maxVariance: config.maxVariance ?? 1,
                minResponses: config.minResponses ?? 1,
            };
        });
        const res = await this.fetchSignaturesFromEncodedMulti({
            recentHash,
            encodedConfigs,
            numSignatures: numSignatures ?? 1,
            useTimestamp,
        });
        return res;
    }
    async fetchSignaturesFromEncodedMulti(params) {
        const { recentHash, encodedConfigs, numSignatures } = params;
        const url = `${this.gatewayUrl}/gateway/api/v1/fetch_signatures_multi`;
        const method = "POST";
        const headers = { "Content-Type": "application/json" };
        const requests = [];
        const body = {
            api_version: "1.0.0",
            num_oracles: numSignatures,
            recent_hash: recentHash ?? bs58.encode(Buffer.alloc(32, 0)),
            signature_scheme: "Secp256k1",
            hash_scheme: "Sha256",
            feed_requests: [],
        };
        for (const config of encodedConfigs) {
            const maxVariance = Math.floor((config.maxVariance ?? 1) * 1e9);
            body.feed_requests.push({
                jobs_b64_encoded: config.encodedJobs,
                max_variance: maxVariance,
                min_responses: config.minResponses ?? 1,
                use_timestamp: params.useTimestamp ?? false,
            });
        }
        const data = JSON.stringify(body);
        try {
            const resp = await axiosClient()(url, { method, headers, data }).then((r) => r.data);
            return resp;
        }
        catch (err) {
            console.error("fetchSignaturesFromEncodedMulti error", err);
            throw err;
        }
    }
    async fetchRandomnessReveal(params) {
        const url = `${this.gatewayUrl}/gateway/api/v1/randomness_reveal`;
        const method = "POST";
        const responseType = "text";
        const headers = { "Content-Type": "application/json" };
        let data;
        if ("slot" in params) {
            data = JSON.stringify({
                slothash: [...bs58.decode(params.slothash)],
                randomness_key: params.randomnessAccount.toBuffer().toString("hex"),
                slot: params.slot,
            });
        }
        else {
            data = JSON.stringify({
                timestamp: params.timestamp,
                min_staleness_seconds: params.minStalenessSeconds,
                randomness_key: params.randomnessId,
            });
        }
        try {
            const txtResponse = await axiosClient()(url, {
                method,
                headers,
                data,
                responseType,
            });
            return JSON.parse(txtResponse.data);
        }
        catch (err) {
            console.error("fetchRandomnessReveal error", err);
            throw err;
        }
    }
    async test() {
        const url = `${this.gatewayUrl}/gateway/api/v1/test`;
        const cachedResponse = GATEWAY_PING_CACHE.get(this.gatewayUrl);
        if (cachedResponse !== undefined) {
            return cachedResponse;
        }
        try {
            const txt = await axiosClient()(url);
            if (txt.data.length !== 0) {
                GATEWAY_PING_CACHE.set(this.gatewayUrl, true);
                return true;
            }
        }
        catch { }
        GATEWAY_PING_CACHE.set(this.gatewayUrl, false);
        return false;
    }
    endpoint() {
        return this.gatewayUrl;
    }
    toString() {
        return JSON.stringify({
            gatewayUrl: this.gatewayUrl,
            programId: this.program.programId.toBase58(),
        });
    }
    [Symbol.toPrimitive](hint) {
        if (hint === "string") {
            return `Gateway: ${this.toString()}`;
        }
        return null;
    }
}
//# sourceMappingURL=gateway.js.map