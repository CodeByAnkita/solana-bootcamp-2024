import { Queue } from "./queue.js";
import { PublicKey, SystemProgram } from "@solana/web3.js";
export class State {
    program;
    pubkey;
    static keyFromSeed(program) {
        const [state] = PublicKey.findProgramAddressSync([Buffer.from("STATE")], program.programId);
        return state;
    }
    static async create(program) {
        const payer = program.provider.wallet.payer;
        const sig = await program.rpc.stateInit({}, {
            accounts: {
                state: State.keyFromSeed(program),
                payer: payer.publicKey,
                systemProgram: SystemProgram.programId,
            },
            signers: [payer],
        });
        return [new State(program), sig];
    }
    constructor(program) {
        this.program = program;
        const pubkey = State.keyFromSeed(program);
        this.pubkey = pubkey;
    }
    async setConfigsIx(params) {
        const state = await this.loadData();
        const queue = params.guardianQueue ?? state.guardianQueue;
        const program = this.program;
        const payer = program.provider.wallet.payer;
        const testOnlyDisableMrEnclaveCheck = params.testOnlyDisableMrEnclaveCheck ??
            state.testOnlyDisableMrEnclaveCheck;
        const resetEpochs = params.resetEpochs ?? false;
        const ix = await this.program.instruction.stateSetConfigs({
            newAuthority: params.newAuthority ?? state.authority,
            testOnlyDisableMrEnclaveCheck: testOnlyDisableMrEnclaveCheck ? 1 : 0,
            stakePool: params.stakePool ?? state.stakePool,
            stakeProgram: params.stakeProgram ?? state.stakeProgram,
            addAdvisory: params.permitAdvisory,
            rmAdvisory: params.denyAdvisory,
            epochLength: params.epochLength ?? state.epochLength,
            resetEpochs: resetEpochs,
            lutSlot: state.lutSlot,
            switchMint: params.switchMint ?? state.switchMint,
            enableStaking: params.enableStaking ?? state.enableStaking,
            authority: params.newAuthority ?? state.authority,
        }, {
            accounts: {
                state: this.pubkey,
                authority: state.authority,
                queue,
                payer: payer.publicKey,
                systemProgram: SystemProgram.programId,
            },
        });
        return ix;
    }
    async registerGuardianIx(params) {
        const state = await this.loadData();
        const program = this.program;
        const payer = program.provider.wallet.payer;
        const ix = await this.program.instruction.guardianRegister({}, {
            accounts: {
                oracle: params.guardian,
                state: this.pubkey,
                guardianQueue: state.guardianQueue,
                authority: state.authority,
            },
            signers: [payer],
        });
        return ix;
    }
    async unregisterGuardianIx(params) {
        const state = await this.loadData();
        const guardianQueue = new Queue(this.program, state.guardianQueue);
        const queueData = await guardianQueue.loadData();
        const idx = queueData.guardians.findIndex((key) => key.equals(params.guardian));
        const program = this.program;
        const payer = program.provider.wallet.payer;
        const ix = await this.program.instruction.guardianUnregister({ idx }, {
            accounts: {
                oracle: params.guardian,
                state: this.pubkey,
                guardianQueue: state.guardianQueue,
                authority: state.authority,
            },
            signers: [payer],
        });
        return ix;
    }
    async loadData() {
        return await this.program.account["state"].fetch(this.pubkey);
    }
    static async loadData(program) {
        const state = new State(program);
        return await state.loadData();
    }
}
//# sourceMappingURL=state.js.map