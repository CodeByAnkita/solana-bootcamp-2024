import * as spl from "./../utils/index.js";
import { State } from "./state.js";
import { BN, BorshAccountsCoder, utils } from "@coral-xyz/anchor";
import { AddressLookupTableProgram, Keypair, PublicKey, SystemProgram, } from "@solana/web3.js";
export class Oracle {
    program;
    pubkey;
    constructor(program, pubkey) {
        this.program = program;
        this.pubkey = pubkey;
    }
    static async create(program, params) {
        const stateKey = State.keyFromSeed(program);
        const state = await State.loadData(program);
        const payer = program.provider.wallet.payer;
        const oracle = Keypair.generate();
        const oracleStats = (await PublicKey.findProgramAddress([Buffer.from("OracleStats"), oracle.publicKey.toBuffer()], program.programId))[0];
        const lutSigner = (await PublicKey.findProgramAddress([Buffer.from("LutSigner"), oracle.publicKey.toBuffer()], program.programId))[0];
        const [delegationPool] = await PublicKey.findProgramAddress([
            Buffer.from("Delegation"),
            stateKey.toBuffer(),
            oracleStats.toBuffer(),
            state.stakePool.toBuffer(),
        ], state.stakeProgram);
        const recentSlot = await program.provider.connection.getSlot("finalized");
        const [_, lut] = AddressLookupTableProgram.createLookupTable({
            authority: lutSigner,
            payer: payer.publicKey,
            recentSlot,
        });
        const ix = await program.instruction.oracleInit({
            recentSlot: new BN(recentSlot.toString()),
            authority: payer.publicKey,
            queue: params.queue,
            secpAuthority: null,
        }, {
            accounts: {
                oracle: oracle.publicKey,
                oracleStats,
                authority: payer.publicKey,
                programState: stateKey,
                payer: payer.publicKey,
                systemProgram: SystemProgram.programId,
                tokenProgram: spl.TOKEN_PROGRAM_ID,
                tokenMint: spl.NATIVE_MINT,
                delegationPool,
                lutSigner,
                lut,
                addressLookupTableProgram: AddressLookupTableProgram.programId,
                switchMint: state.switchMint,
                wsolVault: spl.getAssociatedTokenAddressSync(spl.NATIVE_MINT, oracle.publicKey),
                switchVault: spl.getAssociatedTokenAddressSync(state.switchMint, oracle.publicKey),
                stakeProgram: state.stakeProgram,
                stakePool: state.stakePool,
            },
        });
        const ix2 = await program.instruction.oracleUpdateDelegation({
            recentSlot: new BN(recentSlot.toString()),
        }, {
            accounts: {
                oracle: oracle.publicKey,
                oracleStats,
                queue: params.queue,
                authority: stateKey,
                programState: stateKey,
                payer: payer.publicKey,
                systemProgram: SystemProgram.programId,
                tokenProgram: spl.TOKEN_PROGRAM_ID,
                delegationPool,
                lutSigner,
                lut,
                addressLookupTableProgram: AddressLookupTableProgram.programId,
                switchMint: state.switchMint,
                nativeMint: spl.NATIVE_MINT,
                wsolVault: PublicKey.findProgramAddressSync([
                    Buffer.from("RewardPool"),
                    delegationPool.toBuffer(),
                    spl.NATIVE_MINT.toBuffer(),
                ], state.stakeProgram)[0],
                switchVault: PublicKey.findProgramAddressSync([
                    Buffer.from("RewardPool"),
                    delegationPool.toBuffer(),
                    state.switchMint.toBuffer(),
                ], state.stakeProgram)[0],
                stakeProgram: state.stakeProgram,
                stakePool: state.stakePool,
            },
        });
        return [new Oracle(program, oracle.publicKey), [ix, ix2], oracle];
    }
    async updateDelegationRewardPoolsIx(params) {
        const program = this.program;
        const stateKey = State.keyFromSeed(program);
        const state = await State.loadData(program);
        const switchMint = params.overrideMint ?? state.switchMint;
        const stakePool = params.overrideStakePool ?? state.stakePool;
        const stakeProgram = state.stakeProgram;
        const payer = program.provider.wallet.payer;
        const oracleData = await this.loadData();
        const oracleStats = (await PublicKey.findProgramAddress([Buffer.from("OracleStats"), this.pubkey.toBuffer()], program.programId))[0];
        const lutSigner = (await PublicKey.findProgramAddress([Buffer.from("LutSigner"), this.pubkey.toBuffer()], program.programId))[0];
        const [delegationPool] = await PublicKey.findProgramAddress([
            Buffer.from("Delegation"),
            stateKey.toBuffer(),
            oracleStats.toBuffer(),
            stakePool.toBuffer(),
        ], stakeProgram);
        const lutSlot = oracleData.lutSlot.toNumber();
        const [_, lut] = AddressLookupTableProgram.createLookupTable({
            authority: lutSigner,
            payer: payer.publicKey,
            recentSlot: lutSlot,
        });
        const ix = await program.instruction.oracleUpdateDelegation({
            recentSlot: new BN(lutSlot.toString()),
        }, {
            accounts: {
                oracle: this.pubkey,
                oracleStats,
                queue: oracleData.queue,
                authority: stateKey,
                programState: stateKey,
                payer: payer.publicKey,
                systemProgram: SystemProgram.programId,
                tokenProgram: spl.TOKEN_PROGRAM_ID,
                delegationPool,
                lutSigner,
                lut,
                addressLookupTableProgram: AddressLookupTableProgram.programId,
                switchMint: switchMint,
                nativeMint: spl.NATIVE_MINT,
                wsolVault: PublicKey.findProgramAddressSync([
                    Buffer.from("RewardPool"),
                    delegationPool.toBuffer(),
                    spl.NATIVE_MINT.toBuffer(),
                ], stakeProgram)[0],
                switchVault: PublicKey.findProgramAddressSync([
                    Buffer.from("RewardPool"),
                    delegationPool.toBuffer(),
                    switchMint.toBuffer(),
                ], stakeProgram)[0],
                stakeProgram: stakeProgram,
                stakePool: stakePool,
            },
        });
        return ix;
    }
    async setConfigsIx(params) {
        const data = await this.loadData();
        const ix = await this.program.instruction.oracleSetConfigs({
            authority: params.authority,
            newSecpAuthority: null,
        }, {
            accounts: {
                oracle: this.pubkey,
                authority: params.authority,
            },
        });
        return ix;
    }
    async loadData() {
        return await this.program.account["oracleAccountData"].fetch(this.pubkey);
    }
    static async loadMany(program, keys) {
        const coder = new BorshAccountsCoder(program.idl);
        const accountType = "oracleAccountData";
        const oracleDatas = await utils.rpc
            .getMultipleAccounts(program.provider.connection, keys)
            .then((o) => o.map((x) => coder.decode(accountType, x.account.data)));
        return oracleDatas;
    }
    async verificationStatus() {
        const data = await this.loadData();
        const now = +new Date() / 1000;
        const status = data.enclave.verificationStatus;
        const expiration = data.enclave.validUntil;
        return [status === 4 && now < expiration, expiration.toNumber()];
    }
    async lutKey() {
        const payer = this.program.provider.wallet.payer;
        const data = await this.loadData();
        const lutSigner = (await PublicKey.findProgramAddress([Buffer.from("LutSigner"), this.pubkey.toBuffer()], this.program.programId))[0];
        const [_, lutKey] = await AddressLookupTableProgram.createLookupTable({
            authority: lutSigner,
            payer: payer.publicKey,
            recentSlot: data.lutSlot,
        });
        return lutKey;
    }
    lookupTableKey(data) {
        const lutSigner = PublicKey.findProgramAddressSync([Buffer.from("LutSigner"), this.pubkey.toBuffer()], this.program.programId)[0];
        const [_, lutKey] = AddressLookupTableProgram.createLookupTable({
            authority: lutSigner,
            payer: PublicKey.default,
            recentSlot: data.lutSlot,
        });
        return lutKey;
    }
    async loadLookupTable() {
        const lutKey = await this.lutKey();
        const accnt = await this.program.provider.connection.getAddressLookupTable(lutKey);
        return accnt.value;
    }
}
//# sourceMappingURL=oracle.js.map