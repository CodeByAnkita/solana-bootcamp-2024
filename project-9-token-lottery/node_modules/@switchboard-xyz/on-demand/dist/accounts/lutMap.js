import * as spl from "./../utils/index.js";
import { Queue } from "./queue.js";
import { State } from "./state.js";
import { AddressLookupTableAccount, AddressLookupTableProgram, PublicKey, SystemProgram, } from "@solana/web3.js";
export class LutMap {
    program;
    pubkey;
    static async keyFromSeed(program, queue, authority) {
        const [lut] = PublicKey.findProgramAddressSync([
            Buffer.from("LutMapAccountData"),
            queue.toBuffer(),
            authority.toBuffer(),
        ], program.programId);
        return lut;
    }
    static async create(program, queue, slot) {
        const payer = program.provider.wallet.payer;
        const lutKey = await LutMap.keyFromSeed(program, queue, payer.publicKey);
        const sig = await program.rpc.lutMapInit({ slot }, {
            accounts: {
                lutMap: lutKey,
                queue: queue,
                payer: payer.publicKey,
                authority: payer.publicKey,
                systemProgram: SystemProgram.programId,
            },
            signers: [payer],
        });
        return [new LutMap(program, lutKey), sig];
    }
    constructor(program, pubkey) {
        this.program = program;
        this.pubkey = pubkey;
    }
    async queueLutExtendIx(params) {
        const payer = this.program.provider.wallet.payer;
        const queueAccount = new Queue(this.program, params.queue);
        const queueData = await queueAccount.loadData();
        const lutKey = await LutMap.keyFromSeed(this.program, params.queue, payer.publicKey);
        const lutSigner = (await PublicKey.findProgramAddress([Buffer.from("LutSigner"), params.queue.toBuffer()], this.program.programId))[0];
        const ix = await this.program.instruction.queueLutExtend({ newKey: params.newKey }, {
            accounts: {
                queue: params.queue,
                authority: queueData.authority,
                lutSigner,
                lut: lutKey,
                addressLookupTableProgram: AddressLookupTableProgram.programId,
                payer: payer.publicKey,
                systemProgram: SystemProgram.programId,
            },
        });
        return ix;
    }
    async loadData() {
        return await this.program.account["lutMapAccountData"].fetch(this.pubkey);
    }
    async loadLut() {
        const data = await this.loadData();
        const lutKey = data.lut;
        const lutAccountInfo = await this.program.provider.connection.getAccountInfo(lutKey);
        const lutData = AddressLookupTableAccount.deserialize(lutAccountInfo.data);
        return [lutKey, lutData];
    }
    async syncLut(feeds) {
        const wrapperData = await this.loadData();
        const [key, data] = await this.loadLut();
        const queueKey = wrapperData.queue;
        const queue = new Queue(this.program, queueKey);
        const queueData = await queue.loadData();
        const oracles = queueData.oracleKeys.slice(0, queueData.oracleKeysLen);
        const neededLutAccounts = [];
        neededLutAccounts.push(queueKey);
        neededLutAccounts.push(spl.NATIVE_MINT);
        neededLutAccounts.push(spl.TOKEN_PROGRAM_ID);
        neededLutAccounts.push(spl.ASSOCIATED_TOKEN_PROGRAM_ID);
        neededLutAccounts.push(State.keyFromSeed(this.program));
        for (const oracle of oracles) {
            for (const feed of feeds) {
                const [statsKey] = PublicKey.findProgramAddressSync([Buffer.from("OracleFeedStats"), feed.toBuffer(), oracle.toBuffer()], this.program.programId);
                const feedRewardEscrow = await spl.getAssociatedTokenAddress(spl.NATIVE_MINT, feed);
                neededLutAccounts.push(statsKey);
                neededLutAccounts.push(feed);
                neededLutAccounts.push(oracle);
                neededLutAccounts.push(feedRewardEscrow);
            }
        }
    }
}
//# sourceMappingURL=lutMap.js.map