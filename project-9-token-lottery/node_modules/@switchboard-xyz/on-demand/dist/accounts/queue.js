import { SB_ON_DEMAND_PID } from "../constants.js";
import { Gateway } from "../oracle-interfaces/gateway.js";
import * as spl from "./../utils/index.js";
import { Permission } from "./permission.js";
import { State } from "./state.js";
import * as anchor from "@coral-xyz/anchor";
import { BorshAccountsCoder, utils } from "@coral-xyz/anchor";
import { AddressLookupTableProgram, Keypair, PublicKey, SystemProgram, } from "@solana/web3.js";
function withTimeout(promise, timeoutMs) {
    const timeoutPromise = new Promise((resolve) => setTimeout(resolve, timeoutMs, null));
    return Promise.race([promise, timeoutPromise]);
}
function removeTrailingNullBytes(input) {
    const trailingNullBytesRegex = /\x00+$/;
    return input.replace(trailingNullBytesRegex, "");
}
function runWithTimeout(task, timeoutMs) {
    return new Promise((resolve, reject) => {
        const timer = setTimeout(() => {
            resolve("timeout");
        }, timeoutMs);
        task.then((result) => {
            clearTimeout(timer);
            resolve(result);
        }, (error) => {
            clearTimeout(timer);
            reject(error);
        });
    });
}
export class Queue {
    program;
    pubkey;
    static async createIx(program, params) {
        const stateKey = State.keyFromSeed(program);
        const state = await State.loadData(program);
        const queue = Keypair.generate();
        const allowAuthorityOverrideAfter = params.allowAuthorityOverrideAfter ?? 60 * 60;
        const requireAuthorityHeartbeatPermission = params.requireAuthorityHeartbeatPermission ?? true;
        const requireUsagePermission = params.requireUsagePermission ?? false;
        const maxQuoteVerificationAge = params.maxQuoteVerificationAge ?? 60 * 60 * 24 * 7;
        const reward = params.reward ?? 1000000;
        const nodeTimeout = params.nodeTimeout ?? 300;
        const payer = program.provider.wallet.payer;
        const lutSigner = (await PublicKey.findProgramAddress([Buffer.from("LutSigner"), queue.publicKey.toBuffer()], program.programId))[0];
        const [delegationGroup] = await PublicKey.findProgramAddress([
            Buffer.from("Group"),
            stateKey.toBuffer(),
            state.stakePool.toBuffer(),
            queue.publicKey.toBuffer(),
        ], state.stakeProgram);
        const recentSlot = params.lutSlot ??
            (await program.provider.connection.getSlot("finalized"));
        const [_, lut] = AddressLookupTableProgram.createLookupTable({
            authority: lutSigner,
            payer: payer.publicKey,
            recentSlot,
        });
        let stakePool = state.stakePool;
        if (stakePool.equals(PublicKey.default)) {
            stakePool = payer.publicKey;
        }
        const queueAccount = new Queue(program, queue.publicKey);
        const ix = await program.instruction.queueInit({
            allowAuthorityOverrideAfter,
            requireAuthorityHeartbeatPermission,
            requireUsagePermission,
            maxQuoteVerificationAge,
            reward,
            nodeTimeout,
            recentSlot: new anchor.BN(recentSlot),
        }, {
            accounts: {
                queue: queue.publicKey,
                queueEscrow: await spl.getAssociatedTokenAddress(spl.NATIVE_MINT, queue.publicKey),
                authority: payer.publicKey,
                payer: payer.publicKey,
                systemProgram: SystemProgram.programId,
                tokenProgram: spl.TOKEN_PROGRAM_ID,
                nativeMint: spl.NATIVE_MINT,
                programState: State.keyFromSeed(program),
                lutSigner: await queueAccount.lutSigner(),
                lut: await queueAccount.lutKey(recentSlot),
                addressLookupTableProgram: AddressLookupTableProgram.programId,
                delegationGroup,
                stakeProgram: state.stakeProgram,
                stakePool: stakePool,
                associatedTokenProgram: spl.ASSOCIATED_TOKEN_PROGRAM_ID,
            },
            signers: [payer, queue],
        });
        return [new Queue(program, queue.publicKey), queue, ix];
    }
    async initDelegationGroupIx(params) {
        const queueAccount = new Queue(this.program, this.pubkey);
        const lutSlot = params.lutSlot ?? (await this.loadData()).lutSlot;
        const payer = this.program.provider.wallet.payer;
        const stateKey = State.keyFromSeed(this.program);
        const state = await State.loadData(this.program);
        const stakePool = params.overrideStakePool ?? state.stakePool;
        const [delegationGroup] = await PublicKey.findProgramAddress([
            Buffer.from("Group"),
            stateKey.toBuffer(),
            stakePool.toBuffer(),
            this.pubkey.toBuffer(),
        ], state.stakeProgram);
        const [queueEscrowSigner] = await PublicKey.findProgramAddress([Buffer.from("Signer"), this.pubkey.toBuffer()], SB_ON_DEMAND_PID);
        const ix = await this.program.instruction.queueInitDelegationGroup({}, {
            accounts: {
                queue: this.pubkey,
                queueEscrow: await spl.getAssociatedTokenAddress(spl.NATIVE_MINT, this.pubkey),
                queueEscrowSigner,
                payer: payer.publicKey,
                systemProgram: SystemProgram.programId,
                tokenProgram: spl.TOKEN_PROGRAM_ID,
                nativeMint: spl.NATIVE_MINT,
                programState: stateKey,
                lutSigner: await this.lutSigner(),
                lut: await this.lutKey(lutSlot),
                addressLookupTableProgram: AddressLookupTableProgram.programId,
                delegationGroup: delegationGroup,
                stakeProgram: state.stakeProgram,
                stakePool: stakePool,
            },
        });
        return ix;
    }
    static async fetchSignatures(program, params) {
        const queueAccount = new Queue(program, params.queue);
        return queueAccount.fetchSignatures(params);
    }
    static async fetchSignaturesMulti(program, params) {
        const queueAccount = new Queue(program, params.queue);
        return queueAccount.fetchSignaturesMulti(params);
    }
    static async fetchFeedHash(program, params) {
        const queueAccount = new Queue(program, params.queue);
        const oracleSigs = await queueAccount.fetchSignatures(params);
        return Buffer.from(oracleSigs[0].feed_hash, "hex");
    }
    constructor(program, pubkey) {
        this.program = program;
        this.pubkey = pubkey;
    }
    async fetchOracleKeys() {
        const program = this.program;
        const queueData = (await program.account["queueAccountData"].fetch(this.pubkey));
        const oracles = queueData.oracleKeys.slice(0, queueData.oracleKeysLen);
        return oracles;
    }
    async fetchAllGateways() {
        const queue = this.pubkey;
        const program = this.program;
        const coder = new BorshAccountsCoder(program.idl);
        const oracles = await this.fetchOracleKeys();
        const oracleAccounts = await utils.rpc.getMultipleAccounts(program.provider.connection, oracles);
        const gatewayUris = oracleAccounts
            .map((x) => coder.decode("oracleAccountData", x.account.data))
            .map((x) => String.fromCharCode(...x.gatewayUri))
            .map((x) => removeTrailingNullBytes(x))
            .filter((x) => x.length > 0)
            .filter((x) => !x.includes("infstones"));
        const tests = [];
        for (const i in gatewayUris) {
            const gw = new Gateway(program, gatewayUris[i], oracles[i]);
            tests.push(gw.test());
        }
        let gateways = [];
        for (let i = 0; i < tests.length; i++) {
            try {
                const isGood = await withTimeout(tests[i], 2000);
                if (isGood) {
                    gateways.push(new Gateway(program, gatewayUris[i], oracles[i]));
                }
            }
            catch (e) {
                console.log("Timeout", e);
            }
        }
        gateways = gateways.sort(() => Math.random() - 0.5);
        return gateways;
    }
    async fetchGateway() {
        const gateways = await this.fetchAllGateways();
        if (gateways.length === 0) {
            throw new Error("NoGatewayAvailable");
        }
        return gateways[Math.floor(Math.random() * gateways.length)];
    }
    async fetchSignatures(params) {
        let gateway = new Gateway(this.program, params.gateway ?? "");
        if (params.gateway === undefined) {
            gateway = await this.fetchGateway();
        }
        return await gateway.fetchSignatures(params);
    }
    async fetchSignaturesMulti(params) {
        let gateway = new Gateway(this.program, params.gateway ?? "");
        if (params.gateway === undefined) {
            gateway = await this.fetchGateway();
        }
        return await gateway.fetchSignaturesMulti(params);
    }
    async loadData() {
        return await this.program.account["queueAccountData"].fetch(this.pubkey);
    }
    async addMrEnclaveIx(params) {
        const stateKey = State.keyFromSeed(this.program);
        const state = await State.loadData(this.program);
        const programAuthority = state.authority;
        const { authority } = await this.loadData();
        const ix = await this.program.instruction.queueAddMrEnclave({ mrEnclave: params.mrEnclave }, {
            accounts: {
                queue: this.pubkey,
                authority,
                programAuthority,
                state: stateKey,
            },
        });
        return ix;
    }
    async rmMrEnclaveIx(params) {
        const stateKey = State.keyFromSeed(this.program);
        const state = await State.loadData(this.program);
        const programAuthority = state.authority;
        const { authority } = await this.loadData();
        const ix = await this.program.instruction.queueRemoveMrEnclave({ mrEnclave: params.mrEnclave }, {
            accounts: {
                queue: this.pubkey,
                authority,
                programAuthority,
                state: stateKey,
            },
        });
        return ix;
    }
    async setConfigsIx(params) {
        const data = await this.loadData();
        const stateKey = State.keyFromSeed(this.program);
        let nodeTimeout = null;
        if (params.nodeTimeout !== undefined) {
            nodeTimeout = new anchor.BN(params.nodeTimeout);
        }
        const ix = await this.program.instruction.queueSetConfigs({
            authority: params.authority ?? null,
            reward: params.reward ?? null,
            nodeTimeout: nodeTimeout,
        }, {
            accounts: {
                queue: this.pubkey,
                authority: data.authority,
                state: stateKey,
            },
        });
        return ix;
    }
    async setOraclePermissionIx(params) {
        const data = await this.loadData();
        return Permission.setIx(this.program, {
            authority: data.authority,
            grantee: params.oracle,
            granter: this.pubkey,
            permission: params.permission,
            enable: params.enable,
        });
    }
    async rmAllMrEnclaveIxs() {
        const { mrEnclaves, mrEnclavesLen } = await this.loadData();
        const activeEnclaves = mrEnclaves.slice(0, mrEnclavesLen);
        const ixs = [];
        for (const mrEnclave of activeEnclaves) {
            ixs.push(await this.rmMrEnclaveIx({
                mrEnclave,
            }));
        }
        return ixs;
    }
    async fetchFreshOracle() {
        const coder = new BorshAccountsCoder(this.program.idl);
        const now = Math.floor(+new Date() / 1000);
        const oracles = await this.fetchOracleKeys();
        const oracleAccounts = await utils.rpc.getMultipleAccounts(this.program.provider.connection, oracles);
        const zip = [];
        for (let i = 0; i < oracles.length; i++) {
            zip.push({
                data: coder.decode("oracleAccountData", oracleAccounts[i].account.data),
                key: oracles[i],
            });
        }
        const validOracles = zip
            .filter((x) => x.data.enclave.verificationStatus === 4)
            .filter((x) => x.data.enclave.validUntil > now + 3600);
        const chosen = validOracles[Math.floor(Math.random() * validOracles.length)];
        return chosen.key;
    }
    async lutSigner() {
        return (await PublicKey.findProgramAddress([Buffer.from("LutSigner"), this.pubkey.toBuffer()], this.program.programId))[0];
    }
    async lutKey(lutSlot) {
        const lutSigner = await this.lutSigner();
        const [_, lutKey] = await AddressLookupTableProgram.createLookupTable({
            authority: lutSigner,
            payer: PublicKey.default,
            recentSlot: lutSlot,
        });
        return lutKey;
    }
    async loadLookupTable() {
        const data = await this.loadData();
        const lutKey = await this.lutKey(data.lutSlot);
        const accnt = await this.program.provider.connection.getAddressLookupTable(lutKey);
        return accnt.value;
    }
}
//# sourceMappingURL=queue.js.map