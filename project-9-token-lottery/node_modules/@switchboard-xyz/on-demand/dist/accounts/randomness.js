import { SLOT_HASHES_SYSVAR_ID } from "../constants.js";
import { Gateway } from "../oracle-interfaces/gateway.js";
import { InstructionUtils } from "./../instruction-utils/InstructionUtils.js";
import * as spl from "./../utils/index.js";
import { Oracle } from "./oracle.js";
import { Queue } from "./queue.js";
import { State } from "./state.js";
import * as anchor from "@coral-xyz/anchor";
import { AddressLookupTableProgram, ComputeBudgetProgram, Keypair, PublicKey, SystemProgram, } from "@solana/web3.js";
import { sendTxWithJito } from "@solworks/soltoolkit-sdk/build/modules/TransactionWrapper.js";
import * as bs58 from "bs58";
import * as fs from "fs";
export class Randomness {
    program;
    pubkey;
    constructor(program, pubkey) {
        this.program = program;
        this.pubkey = pubkey;
    }
    async loadData() {
        return await this.program.account["randomnessAccountData"].fetch(this.pubkey);
    }
    static async create(program, kp, queue) {
        const payer = program.provider.wallet.payer;
        const lutSigner = (await PublicKey.findProgramAddress([Buffer.from("LutSigner"), kp.publicKey.toBuffer()], program.programId))[0];
        const recentSlot = await program.provider.connection.getSlot("finalized");
        const [_, lut] = AddressLookupTableProgram.createLookupTable({
            authority: lutSigner,
            payer: payer.publicKey,
            recentSlot,
        });
        const ix = await program.instruction.randomnessInit({
            recentSlot: new anchor.BN(recentSlot.toString()),
        }, {
            accounts: {
                randomness: kp.publicKey,
                queue,
                authority: program.provider.publicKey,
                payer: program.provider.publicKey,
                rewardEscrow: spl.getAssociatedTokenAddressSync(spl.NATIVE_MINT, kp.publicKey),
                systemProgram: SystemProgram.programId,
                tokenProgram: spl.TOKEN_PROGRAM_ID,
                associatedTokenProgram: spl.ASSOCIATED_TOKEN_PROGRAM_ID,
                wrappedSolMint: spl.NATIVE_MINT,
                programState: State.keyFromSeed(program),
                lutSigner,
                lut,
                addressLookupTableProgram: AddressLookupTableProgram.programId,
            },
        });
        return [new Randomness(program, kp.publicKey), ix];
    }
    async commitIx(queue) {
        const queueAccount = new Queue(this.program, queue);
        const oracle = await queueAccount.fetchFreshOracle();
        const ix = await this.program.instruction.randomnessCommit({}, {
            accounts: {
                randomness: this.pubkey,
                queue: queue,
                oracle: oracle,
                recentSlothashes: SLOT_HASHES_SYSVAR_ID,
            },
        });
        return ix;
    }
    async revealIx() {
        const data = await this.loadData();
        const oracleKey = data.oracle;
        const oracle = new Oracle(this.program, oracleKey);
        const oracleData = await oracle.loadData();
        const gatewayUrl = String.fromCharCode(...oracleData.gatewayUri).replace(/\0+$/, "");
        const gateway = new Gateway(this.program, gatewayUrl);
        const gatewayRevealResponse = await gateway.fetchRandomnessReveal({
            randomnessAccount: this.pubkey,
            slothash: bs58.encode(data.seedSlothash),
            slot: data.seedSlot.toNumber(),
        });
        const stats = PublicKey.findProgramAddressSync([Buffer.from("OracleRandomnessStats"), oracleKey.toBuffer()], this.program.programId)[0];
        const ix = await this.program.instruction.randomnessReveal({
            signature: Buffer.from(gatewayRevealResponse.signature, "base64"),
            recoveryId: gatewayRevealResponse.recovery_id,
            value: gatewayRevealResponse.value,
        }, {
            accounts: {
                randomness: this.pubkey,
                oracle: oracleKey,
                queue: data.queue,
                stats,
                authority: data.authority,
                payer: this.program.provider.publicKey,
                recentSlothashes: SLOT_HASHES_SYSVAR_ID,
                systemProgram: SystemProgram.programId,
                rewardEscrow: spl.getAssociatedTokenAddressSync(spl.NATIVE_MINT, this.pubkey),
                tokenProgram: spl.TOKEN_PROGRAM_ID,
                associatedTokenProgram: spl.ASSOCIATED_TOKEN_PROGRAM_ID,
                wrappedSolMint: spl.NATIVE_MINT,
                programState: State.keyFromSeed(this.program),
            },
        });
        return ix;
    }
    async commitAndReveal(callback, signers, queue, configs) {
        const queueAccount = new Queue(this.program, queue);
        const oracle = await queueAccount.fetchFreshOracle();
        const computeUnitPrice = configs?.computeUnitPrice ?? 1;
        const computeUnitLimit = configs?.computeUnitLimit ?? 200_000;
        const connection = this.program.provider.connection;
        const payer = this.program.provider.wallet.payer;
        for (;;) {
            const data = await this.loadData();
            if (data.seedSlot.toNumber() !== 0) {
                console.log("Randomness slot already committed. Jumping to reveal.");
                break;
            }
            const tx = await InstructionUtils.asV0TxWithComputeIxs({
                connection: this.program.provider.connection,
                ixs: [
                    ComputeBudgetProgram.setComputeUnitPrice({
                        microLamports: computeUnitPrice,
                    }),
                    await this.commitIx(oracle),
                ],
            });
            tx.sign([payer]);
            const sim = await connection.simulateTransaction(tx, {
                commitment: "processed",
            });
            if (sim.value.err !== null) {
                console.log(sim.value.logs);
                throw new Error(`Failed to simulate commit transaction: ${JSON.stringify(sim.value.err)}`);
            }
            const sig = await connection.sendTransaction(tx, {
                maxRetries: 2,
                skipPreflight: true,
            });
            console.log(`Commit transaction sent: ${sig}`);
            try {
                await sendTxWithJito({
                    serialisedTx: tx.serialize(),
                    sendOptions: {},
                    region: "mainnet",
                });
            }
            catch (e) {
            }
            try {
                await connection.confirmTransaction(sig);
                console.log(`Commit transaction confirmed: ${sig}`);
                break;
            }
            catch (e) {
                console.log("Failed to confirm commit transaction. Retrying...");
                await new Promise((f) => setTimeout(f, 1000));
                continue;
            }
        }
        await new Promise((f) => setTimeout(f, 1000));
        for (;;) {
            const data = await this.loadData();
            if (data.revealSlot.toNumber() !== 0) {
                break;
            }
            let revealIx = undefined;
            try {
                revealIx = await this.revealIx();
            }
            catch (e) {
                console.log(e);
                console.log("Failed to grab reveal signature. Retrying...");
                await new Promise((f) => setTimeout(f, 1000));
                continue;
            }
            const tx = await InstructionUtils.asV0TxWithComputeIxs({
                connection: this.program.provider.connection,
                ixs: [
                    ComputeBudgetProgram.setComputeUnitPrice({
                        microLamports: computeUnitPrice,
                    }),
                    ComputeBudgetProgram.setComputeUnitLimit({ units: computeUnitLimit }),
                    revealIx,
                    ...callback,
                ],
            });
            tx.sign(signers);
            const sim = await connection.simulateTransaction(tx, {
                commitment: "processed",
            });
            if (sim.value.err !== null) {
                console.log(sim.value.logs);
                throw new Error(`Failed to simulate commit transaction: ${JSON.stringify(sim.value.err)}`);
            }
            const sig = await connection.sendTransaction(tx, {
                maxRetries: 2,
                skipPreflight: true,
            });
            console.log(`RevealAndCallback transaction sent: ${sig}`);
            try {
                await sendTxWithJito({
                    serialisedTx: tx.serialize(),
                    sendOptions: {},
                    region: "mainnet",
                });
            }
            catch (e) {
            }
            await connection.confirmTransaction(sig);
            console.log(`RevealAndCallback transaction confirmed: ${sig}`);
        }
    }
    async serializeIxToFile(revealIxs, fileName = "serializedIx.bin") {
        const tx = await InstructionUtils.asV0TxWithComputeIxs({
            connection: this.program.provider.connection,
            ixs: revealIxs,
            payer: PublicKey.default,
        });
        fs.writeFile(fileName, tx.serialize(), (err) => {
            if (err) {
                console.error("Failed to write to file:", err);
                throw err;
            }
        });
    }
    static async createAndCommitIxs(program, queue) {
        const kp = Keypair.generate();
        const payer = program.provider.wallet.payer;
        const lutSigner = (await PublicKey.findProgramAddress([Buffer.from("LutSigner"), kp.publicKey.toBuffer()], program.programId))[0];
        const recentSlot = await program.provider.connection.getSlot("finalized");
        const [_, lut] = AddressLookupTableProgram.createLookupTable({
            authority: lutSigner,
            payer: payer.publicKey,
            recentSlot,
        });
        const queueAccount = new Queue(program, queue);
        const oracle = await queueAccount.fetchFreshOracle();
        const creationIx = await program.instruction.randomnessInit({}, {
            accounts: {
                randomness: kp.publicKey,
                queue,
                authority: program.provider.publicKey,
                payer: program.provider.publicKey,
                rewardEscrow: spl.getAssociatedTokenAddressSync(spl.NATIVE_MINT, kp.publicKey),
                systemProgram: SystemProgram.programId,
                tokenProgram: spl.TOKEN_PROGRAM_ID,
                associatedTokenProgram: spl.ASSOCIATED_TOKEN_PROGRAM_ID,
                wrappedSolMint: spl.NATIVE_MINT,
                programState: State.keyFromSeed(program),
                lutSigner,
                lut,
                addressLookupTableProgram: AddressLookupTableProgram.programId,
            },
        });
        const newRandomness = new Randomness(program, kp.publicKey);
        const commitIx = await newRandomness.commitIx(oracle);
        return [newRandomness, kp, [creationIx, commitIx]];
    }
}
//# sourceMappingURL=randomness.js.map