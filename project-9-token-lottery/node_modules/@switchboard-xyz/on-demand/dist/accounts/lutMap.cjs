"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LutMap = void 0;
const spl = __importStar(require("./../utils/index.cjs"));
const queue_js_1 = require("./queue.cjs");
const state_js_1 = require("./state.cjs");
const web3_js_1 = require("@solana/web3.js");
class LutMap {
    program;
    pubkey;
    static async keyFromSeed(program, queue, authority) {
        const [lut] = web3_js_1.PublicKey.findProgramAddressSync([
            Buffer.from("LutMapAccountData"),
            queue.toBuffer(),
            authority.toBuffer(),
        ], program.programId);
        return lut;
    }
    static async create(program, queue, slot) {
        const payer = program.provider.wallet.payer;
        const lutKey = await LutMap.keyFromSeed(program, queue, payer.publicKey);
        const sig = await program.rpc.lutMapInit({ slot }, {
            accounts: {
                lutMap: lutKey,
                queue: queue,
                payer: payer.publicKey,
                authority: payer.publicKey,
                systemProgram: web3_js_1.SystemProgram.programId,
            },
            signers: [payer],
        });
        return [new LutMap(program, lutKey), sig];
    }
    constructor(program, pubkey) {
        this.program = program;
        this.pubkey = pubkey;
    }
    async queueLutExtendIx(params) {
        const payer = this.program.provider.wallet.payer;
        const queueAccount = new queue_js_1.Queue(this.program, params.queue);
        const queueData = await queueAccount.loadData();
        const lutKey = await LutMap.keyFromSeed(this.program, params.queue, payer.publicKey);
        const lutSigner = (await web3_js_1.PublicKey.findProgramAddress([Buffer.from("LutSigner"), params.queue.toBuffer()], this.program.programId))[0];
        const ix = await this.program.instruction.queueLutExtend({ newKey: params.newKey }, {
            accounts: {
                queue: params.queue,
                authority: queueData.authority,
                lutSigner,
                lut: lutKey,
                addressLookupTableProgram: web3_js_1.AddressLookupTableProgram.programId,
                payer: payer.publicKey,
                systemProgram: web3_js_1.SystemProgram.programId,
            },
        });
        return ix;
    }
    async loadData() {
        return await this.program.account["lutMapAccountData"].fetch(this.pubkey);
    }
    async loadLut() {
        const data = await this.loadData();
        const lutKey = data.lut;
        const lutAccountInfo = await this.program.provider.connection.getAccountInfo(lutKey);
        const lutData = web3_js_1.AddressLookupTableAccount.deserialize(lutAccountInfo.data);
        return [lutKey, lutData];
    }
    async syncLut(feeds) {
        const wrapperData = await this.loadData();
        const [key, data] = await this.loadLut();
        const queueKey = wrapperData.queue;
        const queue = new queue_js_1.Queue(this.program, queueKey);
        const queueData = await queue.loadData();
        const oracles = queueData.oracleKeys.slice(0, queueData.oracleKeysLen);
        const neededLutAccounts = [];
        neededLutAccounts.push(queueKey);
        neededLutAccounts.push(spl.NATIVE_MINT);
        neededLutAccounts.push(spl.TOKEN_PROGRAM_ID);
        neededLutAccounts.push(spl.ASSOCIATED_TOKEN_PROGRAM_ID);
        neededLutAccounts.push(state_js_1.State.keyFromSeed(this.program));
        for (const oracle of oracles) {
            for (const feed of feeds) {
                const [statsKey] = web3_js_1.PublicKey.findProgramAddressSync([Buffer.from("OracleFeedStats"), feed.toBuffer(), oracle.toBuffer()], this.program.programId);
                const feedRewardEscrow = await spl.getAssociatedTokenAddress(spl.NATIVE_MINT, feed);
                neededLutAccounts.push(statsKey);
                neededLutAccounts.push(feed);
                neededLutAccounts.push(oracle);
                neededLutAccounts.push(feedRewardEscrow);
            }
        }
    }
}
exports.LutMap = LutMap;
//# sourceMappingURL=lutMap.js.map