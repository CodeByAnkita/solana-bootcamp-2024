"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Randomness = void 0;
const constants_js_1 = require("../constants.cjs");
const gateway_js_1 = require("../oracle-interfaces/gateway.cjs");
const InstructionUtils_js_1 = require("./../instruction-utils/InstructionUtils.cjs");
const spl = __importStar(require("./../utils/index.cjs"));
const oracle_js_1 = require("./oracle.cjs");
const queue_js_1 = require("./queue.cjs");
const state_js_1 = require("./state.cjs");
const anchor = __importStar(require("@coral-xyz/anchor"));
const web3_js_1 = require("@solana/web3.js");
const TransactionWrapper_js_1 = require("@solworks/soltoolkit-sdk/build/modules/TransactionWrapper.js");
const bs58 = __importStar(require("bs58"));
const fs = __importStar(require("fs"));
class Randomness {
    program;
    pubkey;
    constructor(program, pubkey) {
        this.program = program;
        this.pubkey = pubkey;
    }
    async loadData() {
        return await this.program.account["randomnessAccountData"].fetch(this.pubkey);
    }
    static async create(program, kp, queue) {
        const payer = program.provider.wallet.payer;
        const lutSigner = (await web3_js_1.PublicKey.findProgramAddress([Buffer.from("LutSigner"), kp.publicKey.toBuffer()], program.programId))[0];
        const recentSlot = await program.provider.connection.getSlot("finalized");
        const [_, lut] = web3_js_1.AddressLookupTableProgram.createLookupTable({
            authority: lutSigner,
            payer: payer.publicKey,
            recentSlot,
        });
        const ix = await program.instruction.randomnessInit({
            recentSlot: new anchor.BN(recentSlot.toString()),
        }, {
            accounts: {
                randomness: kp.publicKey,
                queue,
                authority: program.provider.publicKey,
                payer: program.provider.publicKey,
                rewardEscrow: spl.getAssociatedTokenAddressSync(spl.NATIVE_MINT, kp.publicKey),
                systemProgram: web3_js_1.SystemProgram.programId,
                tokenProgram: spl.TOKEN_PROGRAM_ID,
                associatedTokenProgram: spl.ASSOCIATED_TOKEN_PROGRAM_ID,
                wrappedSolMint: spl.NATIVE_MINT,
                programState: state_js_1.State.keyFromSeed(program),
                lutSigner,
                lut,
                addressLookupTableProgram: web3_js_1.AddressLookupTableProgram.programId,
            },
        });
        return [new Randomness(program, kp.publicKey), ix];
    }
    async commitIx(queue) {
        const queueAccount = new queue_js_1.Queue(this.program, queue);
        const oracle = await queueAccount.fetchFreshOracle();
        const ix = await this.program.instruction.randomnessCommit({}, {
            accounts: {
                randomness: this.pubkey,
                queue: queue,
                oracle: oracle,
                recentSlothashes: constants_js_1.SLOT_HASHES_SYSVAR_ID,
            },
        });
        return ix;
    }
    async revealIx() {
        const data = await this.loadData();
        const oracleKey = data.oracle;
        const oracle = new oracle_js_1.Oracle(this.program, oracleKey);
        const oracleData = await oracle.loadData();
        const gatewayUrl = String.fromCharCode(...oracleData.gatewayUri).replace(/\0+$/, "");
        const gateway = new gateway_js_1.Gateway(this.program, gatewayUrl);
        const gatewayRevealResponse = await gateway.fetchRandomnessReveal({
            randomnessAccount: this.pubkey,
            slothash: bs58.encode(data.seedSlothash),
            slot: data.seedSlot.toNumber(),
        });
        const stats = web3_js_1.PublicKey.findProgramAddressSync([Buffer.from("OracleRandomnessStats"), oracleKey.toBuffer()], this.program.programId)[0];
        const ix = await this.program.instruction.randomnessReveal({
            signature: Buffer.from(gatewayRevealResponse.signature, "base64"),
            recoveryId: gatewayRevealResponse.recovery_id,
            value: gatewayRevealResponse.value,
        }, {
            accounts: {
                randomness: this.pubkey,
                oracle: oracleKey,
                queue: data.queue,
                stats,
                authority: data.authority,
                payer: this.program.provider.publicKey,
                recentSlothashes: constants_js_1.SLOT_HASHES_SYSVAR_ID,
                systemProgram: web3_js_1.SystemProgram.programId,
                rewardEscrow: spl.getAssociatedTokenAddressSync(spl.NATIVE_MINT, this.pubkey),
                tokenProgram: spl.TOKEN_PROGRAM_ID,
                associatedTokenProgram: spl.ASSOCIATED_TOKEN_PROGRAM_ID,
                wrappedSolMint: spl.NATIVE_MINT,
                programState: state_js_1.State.keyFromSeed(this.program),
            },
        });
        return ix;
    }
    async commitAndReveal(callback, signers, queue, configs) {
        const queueAccount = new queue_js_1.Queue(this.program, queue);
        const oracle = await queueAccount.fetchFreshOracle();
        const computeUnitPrice = configs?.computeUnitPrice ?? 1;
        const computeUnitLimit = configs?.computeUnitLimit ?? 200_000;
        const connection = this.program.provider.connection;
        const payer = this.program.provider.wallet.payer;
        for (;;) {
            const data = await this.loadData();
            if (data.seedSlot.toNumber() !== 0) {
                console.log("Randomness slot already committed. Jumping to reveal.");
                break;
            }
            const tx = await InstructionUtils_js_1.InstructionUtils.asV0TxWithComputeIxs({
                connection: this.program.provider.connection,
                ixs: [
                    web3_js_1.ComputeBudgetProgram.setComputeUnitPrice({
                        microLamports: computeUnitPrice,
                    }),
                    await this.commitIx(oracle),
                ],
            });
            tx.sign([payer]);
            const sim = await connection.simulateTransaction(tx, {
                commitment: "processed",
            });
            if (sim.value.err !== null) {
                console.log(sim.value.logs);
                throw new Error(`Failed to simulate commit transaction: ${JSON.stringify(sim.value.err)}`);
            }
            const sig = await connection.sendTransaction(tx, {
                maxRetries: 2,
                skipPreflight: true,
            });
            console.log(`Commit transaction sent: ${sig}`);
            try {
                await (0, TransactionWrapper_js_1.sendTxWithJito)({
                    serialisedTx: tx.serialize(),
                    sendOptions: {},
                    region: "mainnet",
                });
            }
            catch (e) {
            }
            try {
                await connection.confirmTransaction(sig);
                console.log(`Commit transaction confirmed: ${sig}`);
                break;
            }
            catch (e) {
                console.log("Failed to confirm commit transaction. Retrying...");
                await new Promise((f) => setTimeout(f, 1000));
                continue;
            }
        }
        await new Promise((f) => setTimeout(f, 1000));
        for (;;) {
            const data = await this.loadData();
            if (data.revealSlot.toNumber() !== 0) {
                break;
            }
            let revealIx = undefined;
            try {
                revealIx = await this.revealIx();
            }
            catch (e) {
                console.log(e);
                console.log("Failed to grab reveal signature. Retrying...");
                await new Promise((f) => setTimeout(f, 1000));
                continue;
            }
            const tx = await InstructionUtils_js_1.InstructionUtils.asV0TxWithComputeIxs({
                connection: this.program.provider.connection,
                ixs: [
                    web3_js_1.ComputeBudgetProgram.setComputeUnitPrice({
                        microLamports: computeUnitPrice,
                    }),
                    web3_js_1.ComputeBudgetProgram.setComputeUnitLimit({ units: computeUnitLimit }),
                    revealIx,
                    ...callback,
                ],
            });
            tx.sign(signers);
            const sim = await connection.simulateTransaction(tx, {
                commitment: "processed",
            });
            if (sim.value.err !== null) {
                console.log(sim.value.logs);
                throw new Error(`Failed to simulate commit transaction: ${JSON.stringify(sim.value.err)}`);
            }
            const sig = await connection.sendTransaction(tx, {
                maxRetries: 2,
                skipPreflight: true,
            });
            console.log(`RevealAndCallback transaction sent: ${sig}`);
            try {
                await (0, TransactionWrapper_js_1.sendTxWithJito)({
                    serialisedTx: tx.serialize(),
                    sendOptions: {},
                    region: "mainnet",
                });
            }
            catch (e) {
            }
            await connection.confirmTransaction(sig);
            console.log(`RevealAndCallback transaction confirmed: ${sig}`);
        }
    }
    async serializeIxToFile(revealIxs, fileName = "serializedIx.bin") {
        const tx = await InstructionUtils_js_1.InstructionUtils.asV0TxWithComputeIxs({
            connection: this.program.provider.connection,
            ixs: revealIxs,
            payer: web3_js_1.PublicKey.default,
        });
        fs.writeFile(fileName, tx.serialize(), (err) => {
            if (err) {
                console.error("Failed to write to file:", err);
                throw err;
            }
        });
    }
    static async createAndCommitIxs(program, queue) {
        const kp = web3_js_1.Keypair.generate();
        const payer = program.provider.wallet.payer;
        const lutSigner = (await web3_js_1.PublicKey.findProgramAddress([Buffer.from("LutSigner"), kp.publicKey.toBuffer()], program.programId))[0];
        const recentSlot = await program.provider.connection.getSlot("finalized");
        const [_, lut] = web3_js_1.AddressLookupTableProgram.createLookupTable({
            authority: lutSigner,
            payer: payer.publicKey,
            recentSlot,
        });
        const queueAccount = new queue_js_1.Queue(program, queue);
        const oracle = await queueAccount.fetchFreshOracle();
        const creationIx = await program.instruction.randomnessInit({}, {
            accounts: {
                randomness: kp.publicKey,
                queue,
                authority: program.provider.publicKey,
                payer: program.provider.publicKey,
                rewardEscrow: spl.getAssociatedTokenAddressSync(spl.NATIVE_MINT, kp.publicKey),
                systemProgram: web3_js_1.SystemProgram.programId,
                tokenProgram: spl.TOKEN_PROGRAM_ID,
                associatedTokenProgram: spl.ASSOCIATED_TOKEN_PROGRAM_ID,
                wrappedSolMint: spl.NATIVE_MINT,
                programState: state_js_1.State.keyFromSeed(program),
                lutSigner,
                lut,
                addressLookupTableProgram: web3_js_1.AddressLookupTableProgram.programId,
            },
        });
        const newRandomness = new Randomness(program, kp.publicKey);
        const commitIx = await newRandomness.commitIx(oracle);
        return [newRandomness, kp, [creationIx, commitIx]];
    }
}
exports.Randomness = Randomness;
//# sourceMappingURL=randomness.js.map