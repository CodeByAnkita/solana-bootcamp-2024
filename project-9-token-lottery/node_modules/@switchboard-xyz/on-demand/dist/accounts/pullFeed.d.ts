/// <reference types="node" resolution-mode="require"/>
import type { FeedEvalResponse } from "../oracle-interfaces/gateway.js";
import { Oracle } from "./oracle.js";
import type { Program } from "@coral-xyz/anchor";
import * as anchor from "@coral-xyz/anchor";
import type { AddressLookupTableAccount, TransactionInstruction, VersionedTransaction } from "@solana/web3.js";
import { Keypair, PublicKey } from "@solana/web3.js";
import type { IOracleJob, OracleJob } from "@switchboard-xyz/common";
import { CrossbarClient } from "@switchboard-xyz/common";
import Big from "big.js";
export type MultiSubmission = {
    values: anchor.BN[];
    signature: Buffer;
    recoveryId: number;
};
export type OracleResponse = {
    oracle: Oracle;
    value: Big | null;
    error: string;
};
export type FeedRequest = {
    maxVariance: number;
    minResponses: number;
    jobs: OracleJob[];
};
export type FeedSubmission = {
    value: Big;
    slot: anchor.BN;
    oracle: PublicKey;
};
export declare function toFeedValue(submissions: FeedSubmission[], onlyAfter: anchor.BN): FeedSubmission | null;
export declare class PullFeed {
    readonly program: Program;
    gatewayUrl: string;
    pubkey: PublicKey;
    constructor(program: Program, pubkey: PublicKey | string);
    static generate(program: Program): [PullFeed, Keypair];
    static initTx(program: Program, params: {
        name: string;
        queue: PublicKey;
        maxVariance: number;
        minResponses: number;
        minSampleSize: number;
        maxStaleness: number;
        payer?: PublicKey;
    } & ({
        feedHash: Buffer;
    } | {
        jobs: IOracleJob[];
    })): Promise<[PullFeed, VersionedTransaction]>;
    private static feedHashFromParams;
    initIx(params: {
        name: string;
        queue: PublicKey;
        maxVariance: number;
        minResponses: number;
        payer?: PublicKey;
        minSampleSize: number;
        maxStaleness: number;
    } & ({
        feedHash: Buffer;
    } | {
        jobs: IOracleJob[];
    })): Promise<TransactionInstruction>;
    closeIx(): Promise<TransactionInstruction>;
    setConfigsIx(params: {
        name?: string;
        authority?: PublicKey;
        maxVariance?: number;
        minResponses?: number;
        feedHash?: Buffer;
        jobs?: IOracleJob[];
        minSampleSize?: number;
        maxStaleness?: number;
    }): Promise<TransactionInstruction>;
    fetchUpdateIx(params_?: {
        gateway?: string;
        numSignatures?: number;
        feedConfigs?: FeedRequest;
        jobs?: IOracleJob[];
        crossbarClient?: CrossbarClient;
    }, recentSlothashes?: Array<[anchor.BN, string]>, priceSignatures?: FeedEvalResponse[], debug?: boolean): Promise<[
        TransactionInstruction | undefined,
        OracleResponse[],
        number,
        any[]
    ]>;
    loadConfigs(): Promise<any>;
    static fetchUpdateIx(program: Program, params_: {
        gateway?: string;
        queue: PublicKey;
        feed: PublicKey;
        numSignatures: number;
        maxVariance: number;
        minResponses: number;
        jobs?: IOracleJob[];
        crossbarClient?: CrossbarClient;
    }, recentSlothashes?: Array<[anchor.BN, string]>, priceSignatures?: FeedEvalResponse[], debug?: boolean, payer?: PublicKey): Promise<[
        TransactionInstruction | undefined,
        OracleResponse[],
        number,
        any[]
    ]>;
    static fetchUpdateManyIx(program: Program, params_: {
        gateway?: string;
        feeds: PublicKey[];
        numSignatures: number;
        crossbarClient?: CrossbarClient;
    }, recentSlothashes?: Array<[anchor.BN, string]>, debug?: boolean, payer?: PublicKey): Promise<[TransactionInstruction, AddressLookupTableAccount[], any]>;
    getSolanaSubmitSignaturesIx(params: {
        resps: FeedEvalResponse[];
        offsets: number[];
        slot: anchor.BN;
        payer?: PublicKey;
    }): TransactionInstruction;
    isInitializedAsync(): Promise<boolean>;
    loadData(): Promise<any>;
    loadValues(): Promise<Array<{
        value: Big;
        slot: anchor.BN;
        oracle: PublicKey;
    }>>;
    loadObservedValue(onlyAfter: anchor.BN): Promise<{
        value: Big;
        slot: anchor.BN;
        oracle: PublicKey;
    } | null>;
    subscribeToValueChanges(callback: any): Promise<number>;
    static subscribeToAllUpdates(program: Program, callback: (event: [number, {
        pubkey: PublicKey;
        submissions: FeedSubmission[];
    }]) => Promise<void>): Promise<number>;
    lookupTableKey(data: any): PublicKey;
    loadLookupTable(): Promise<AddressLookupTableAccount>;
}
//# sourceMappingURL=pullFeed.d.ts.map