import { SLOT_HASHES_SYSVAR_ID } from "../constants.js";
import { InstructionUtils } from "./../instruction-utils/InstructionUtils.js";
import { RecentSlotHashes } from "./../sysvars/recentSlothashes.js";
import * as spl from "./../utils/index.js";
import { loadLookupTables } from "./../utils/index.js";
import { Oracle } from "./oracle.js";
import { Queue } from "./queue.js";
import { State } from "./state.js";
import { BorshAccountsCoder } from "@coral-xyz/anchor";
import * as anchor from "@coral-xyz/anchor";
import { AddressLookupTableProgram, Keypair, PublicKey, SystemProgram, } from "@solana/web3.js";
import { CrossbarClient, FeedHash } from "@switchboard-xyz/common";
import Big from "big.js";
function padStringWithNullBytes(input, desiredLength = 32) {
    const nullByte = "\0";
    while (input.length < desiredLength) {
        input += nullByte;
    }
    return input;
}
export function toFeedValue(submissions, onlyAfter) {
    let values = submissions.filter((x) => x.slot.gt(onlyAfter));
    if (values.length === 0) {
        return null;
    }
    values = values.sort((x, y) => (x.value.lt(y.value) ? -1 : 1));
    return values[Math.floor(values.length / 2)];
}
async function checkNeedsInit(connection, programId, pubkey) {
    const accountInfo = await connection.getAccountInfo(pubkey);
    if (accountInfo === null)
        return true;
    const owner = accountInfo.owner;
    if (!owner.equals(programId))
        return true;
    return false;
}
export class PullFeed {
    program;
    gatewayUrl;
    pubkey;
    constructor(program, pubkey) {
        this.program = program;
        this.gatewayUrl = "";
        this.pubkey = new PublicKey(pubkey);
    }
    static generate(program) {
        const keypair = Keypair.generate();
        const feed = new PullFeed(program, keypair.publicKey);
        return [feed, keypair];
    }
    static async initTx(program, params) {
        const [pullFeed, keypair] = PullFeed.generate(program);
        const ix = await pullFeed.initIx(params);
        const tx = await InstructionUtils.asV0TxWithComputeIxs({
            connection: program.provider.connection,
            ixs: [ix],
        });
        tx.sign([keypair]);
        return [pullFeed, tx];
    }
    static feedHashFromParams(params) {
        const hash = (() => {
            if (params.feedHash) {
                return params.feedHash;
            }
            else if (params.jobs?.length) {
                return FeedHash.compute(params.queue.toBuffer(), params.jobs);
            }
            throw new Error('Either "feedHash" or "jobs" must be provided.');
        })();
        if (hash.byteLength === 32)
            return hash;
        throw new Error("Feed hash must be 32 bytes");
    }
    async initIx(params) {
        const feedHash = PullFeed.feedHashFromParams({
            queue: params.queue,
            feedHash: "feedHash" in params ? params.feedHash : undefined,
            jobs: "jobs" in params ? params.jobs : undefined,
        });
        const payerPublicKey = params.payer ?? this.program.provider.publicKey ?? PublicKey.default;
        const maxVariance = Math.floor(params.maxVariance * 1e9);
        const lutSigner = (await PublicKey.findProgramAddress([Buffer.from("LutSigner"), this.pubkey.toBuffer()], this.program.programId))[0];
        const recentSlot = await this.program.provider.connection.getSlot("finalized");
        const [_, lut] = AddressLookupTableProgram.createLookupTable({
            authority: lutSigner,
            payer: payerPublicKey,
            recentSlot,
        });
        const ix = this.program.instruction.pullFeedInit({
            feedHash: feedHash,
            maxVariance: new anchor.BN(maxVariance),
            minResponses: params.minResponses,
            name: Buffer.from(padStringWithNullBytes(params.name)),
            recentSlot: new anchor.BN(recentSlot),
            ipfsHash: new Uint8Array(32),
            minSampleSize: params.minSampleSize,
            maxStaleness: params.maxStaleness,
        }, {
            accounts: {
                pullFeed: this.pubkey,
                queue: params.queue,
                authority: payerPublicKey,
                payer: payerPublicKey,
                systemProgram: SystemProgram.programId,
                programState: State.keyFromSeed(this.program),
                rewardEscrow: spl.getAssociatedTokenAddressSync(spl.NATIVE_MINT, this.pubkey),
                tokenProgram: spl.TOKEN_PROGRAM_ID,
                associatedTokenProgram: spl.ASSOCIATED_TOKEN_PROGRAM_ID,
                wrappedSolMint: spl.NATIVE_MINT,
                lutSigner,
                lut,
                addressLookupTableProgram: AddressLookupTableProgram.programId,
            },
        });
        return ix;
    }
    async closeIx() {
        const payerPublicKey = this.program.provider.publicKey;
        const lutSigner = (await PublicKey.findProgramAddress([Buffer.from("LutSigner"), this.pubkey.toBuffer()], this.program.programId))[0];
        const data = await this.loadData();
        const [_, lut] = AddressLookupTableProgram.createLookupTable({
            authority: lutSigner,
            payer: payerPublicKey,
            recentSlot: data.lutSlot,
        });
        const ix = this.program.instruction.pullFeedClose({}, {
            accounts: {
                pullFeed: this.pubkey,
                authority: data.authority,
                payer: payerPublicKey,
                rewardEscrow: spl.getAssociatedTokenAddressSync(spl.NATIVE_MINT, this.pubkey),
                lutSigner,
                lut,
                state: State.keyFromSeed(this.program),
                tokenProgram: spl.TOKEN_PROGRAM_ID,
                associatedTokenProgram: spl.ASSOCIATED_TOKEN_PROGRAM_ID,
                systemProgram: SystemProgram.programId,
                addressLookupTableProgram: AddressLookupTableProgram.programId,
            },
        });
        return ix;
    }
    async setConfigsIx(params) {
        const data = await this.loadData();
        const name = params.name !== undefined
            ? Buffer.from(padStringWithNullBytes(params.name))
            : null;
        const feedHash = params.feedHash || params.jobs
            ? PullFeed.feedHashFromParams({
                queue: data.queue,
                feedHash: params.feedHash,
                jobs: params.jobs,
            })
            : null;
        const ix = this.program.instruction.pullFeedSetConfigs({
            name: name,
            feedHash: feedHash,
            authority: params.authority ?? null,
            maxVariance: params.maxVariance !== undefined
                ? new anchor.BN(Math.floor(params.maxVariance * 1e9))
                : null,
            minResponses: params.minResponses ?? null,
            minSampleSize: params.minSampleSize ?? null,
            maxStaleness: params.maxStaleness ?? null,
            ipfsHash: null,
        }, {
            accounts: {
                pullFeed: this.pubkey,
                authority: data.authority,
            },
        });
        return ix;
    }
    async fetchUpdateIx(params_, recentSlothashes, priceSignatures, debug = false) {
        const feedConfigs = params_?.feedConfigs ?? (await this.loadConfigs());
        const numSignatures = params_?.numSignatures ??
            feedConfigs.minResponses + Math.ceil(feedConfigs.minResponses / 3);
        const queueAccount = new Queue(this.program, feedConfigs.queue);
        if (this.gatewayUrl === "") {
            this.gatewayUrl =
                params_?.gateway ??
                    (await queueAccount.fetchAllGateways())[0].gatewayUrl;
        }
        const params = {
            feed: this.pubkey,
            gateway: this.gatewayUrl,
            ...feedConfigs,
            ...params_,
            numSignatures,
        };
        const ix = await PullFeed.fetchUpdateIx(this.program, params, recentSlothashes, priceSignatures, debug);
        return ix;
    }
    async loadConfigs() {
        const data = await this.loadData();
        const maxVariance = data.maxVariance / 1e9;
        return {
            queue: data.queue,
            maxVariance: maxVariance,
            minResponses: data.minResponses,
            feedHash: data.feedHash,
            ipfsHash: data.ipfsHash,
        };
    }
    static async fetchUpdateIx(program, params_, recentSlothashes, priceSignatures, debug = false, payer) {
        const slotHashes = recentSlothashes ??
            (await RecentSlotHashes.fetchLatestNSlothashes(program.provider.connection, 30));
        const feed = new PullFeed(program, params_.feed);
        const params = params_;
        if (!params_.jobs?.length) {
            const data = await feed.loadData();
            params.jobs = await (params_.crossbarClient ?? CrossbarClient.default())
                .fetch(Buffer.from(data.feedHash).toString("hex"))
                .then((resp) => resp.jobs);
        }
        params.recentHash = slotHashes[0][1];
        priceSignatures =
            priceSignatures ?? (await Queue.fetchSignatures(program, params));
        let numSuccesses = 0;
        if (!priceSignatures) {
            return [undefined, [], 0, []];
        }
        const oracleResponses = priceSignatures.map((x) => {
            const oldDP = Big.DP;
            Big.DP = 40;
            const value = x.success_value ? new Big(x.success_value).div(1e18) : null;
            if (value !== null) {
                numSuccesses += 1;
            }
            Big.DP = oldDP;
            return {
                value,
                error: x.failure_error,
                oracle: new Oracle(program, new PublicKey(Buffer.from(x.oracle_pubkey, "hex"))),
            };
        });
        const offsets = new Array(priceSignatures.length).fill(0);
        for (let i = 0; i < priceSignatures.length; i++) {
            if (priceSignatures[i].failure_error.length > 0) {
                let validResp = false;
                for (const recentSignature of priceSignatures[i]
                    .recent_successes_if_failed) {
                    for (let offset = 0; offset < slotHashes.length; offset++) {
                        const slotHash = slotHashes[offset];
                        if (slotHash[1] === recentSignature.recent_hash) {
                            priceSignatures[i] = recentSignature;
                            offsets[i] = offset;
                            validResp = true;
                            break;
                        }
                    }
                    if (validResp) {
                        break;
                    }
                }
            }
        }
        if (debug) {
            console.log("priceSignatures", priceSignatures);
        }
        let submitSignaturesIx = undefined;
        if (numSuccesses > 0) {
            submitSignaturesIx = feed.getSolanaSubmitSignaturesIx({
                resps: priceSignatures,
                offsets: offsets,
                slot: slotHashes[0][0],
                payer,
            });
        }
        const lutOwners = [...oracleResponses.map((x) => x.oracle), feed];
        const luts = await loadLookupTables(lutOwners);
        if (!numSuccesses) {
            throw new Error(`PullFeed.fetchUpdateIx Failure: ${oracleResponses.map((x) => x.error)}`);
        }
        return [submitSignaturesIx, oracleResponses, numSuccesses, luts];
    }
    static async fetchUpdateManyIx(program, params_, recentSlothashes, debug = false, payer) {
        const slotHashes = recentSlothashes ??
            (await RecentSlotHashes.fetchLatestNSlothashes(program.provider.connection, 30));
        const feeds = params_.feeds.map((feed) => new PullFeed(program, feed));
        const params = params_;
        const feedConfigs = [];
        for (const feed of feeds) {
            const data = await feed.loadData();
            const maxVariance = data.maxVariance / 1e9;
            const minResponses = data.minResponses;
            const jobs = await (params_.crossbarClient ?? CrossbarClient.default())
                .fetch(Buffer.from(data.feedHash).toString("hex"))
                .then((resp) => resp.jobs);
            feedConfigs.push({
                maxVariance,
                minResponses,
                jobs,
            });
        }
        params.recentHash = slotHashes[0][1];
        params.feedConfigs = feedConfigs;
        const response = await Queue.fetchSignaturesMulti(program, params);
        const numResponses = response.oracle_responses.length;
        const oracles = [];
        const submissions = [];
        const queueKey = Buffer.from(response.oracle_responses[0].feed_responses[0].queue_pubkey, "hex");
        for (let i = 0; i < response.oracle_responses.length; i++) {
            oracles.push(new PublicKey(Buffer.from(response.oracle_responses[i].feed_responses[0].oracle_pubkey, "hex")));
            const oracleResponse = response.oracle_responses[i];
            const feedResponses = oracleResponse.feed_responses;
            const multisSubmission = {
                values: feedResponses.map((x) => new anchor.BN(x.success_value)),
                signature: Buffer.from(oracleResponse.signature, "base64"),
                recoveryId: oracleResponse.recovery_id,
            };
            submissions.push(multisSubmission);
        }
        const payerPublicKey = params.payer ?? program.provider.publicKey ?? PublicKey.default;
        const queue = new PublicKey(queueKey);
        const oracleFeedStats = oracles.map((oracle) => PublicKey.findProgramAddressSync([Buffer.from("OracleStats"), oracle.toBuffer()], program.programId)[0]);
        const instructionData = {
            slot: new anchor.BN(slotHashes[0][0]),
            submissions,
        };
        const accounts = {
            queue: queue,
            programState: State.keyFromSeed(program),
            recentSlothashes: SLOT_HASHES_SYSVAR_ID,
            payer: payerPublicKey,
            systemProgram: SystemProgram.programId,
            rewardVault: spl.getAssociatedTokenAddressSync(spl.NATIVE_MINT, queue),
            tokenProgram: spl.TOKEN_PROGRAM_ID,
            tokenMint: spl.NATIVE_MINT,
        };
        const remainingAccounts = [
            ...feeds.map((k) => ({
                pubkey: k.pubkey,
                isSigner: false,
                isWritable: true,
            })),
            ...oracles.map((k) => ({
                pubkey: k,
                isSigner: false,
                isWritable: false,
            })),
            ...oracleFeedStats.map((k) => ({
                pubkey: k,
                isSigner: false,
                isWritable: true,
            })),
        ];
        const lutLoaders = [];
        for (const feed of feeds) {
            lutLoaders.push(feed.loadLookupTable());
        }
        for (const oracleKey of oracles) {
            const oracle = new Oracle(program, oracleKey);
            lutLoaders.push(oracle.loadLookupTable());
        }
        const luts = await Promise.all(lutLoaders);
        const ix = program.instruction.pullFeedSubmitResponseMany(instructionData, {
            accounts,
            remainingAccounts,
        });
        return [ix, luts, response];
    }
    getSolanaSubmitSignaturesIx(params) {
        const program = this.program;
        const payerPublicKey = params.payer ?? program.provider.publicKey ?? PublicKey.default;
        const resps = params.resps.filter((x) => (x.signature ?? "").length > 0);
        const queue = new PublicKey(Buffer.from(resps[0].queue_pubkey.toString(), "hex"));
        const oracles = resps.map((x) => new PublicKey(Buffer.from(x.oracle_pubkey.toString(), "hex")));
        const oracleFeedStats = oracles.map((oracle) => PublicKey.findProgramAddressSync([Buffer.from("OracleStats"), oracle.toBuffer()], program.programId)[0]);
        const submissions = resps.map((resp, idx) => ({
            value: new anchor.BN(resp.success_value.toString()),
            signature: resp.signature,
            recoveryId: resp.recovery_id,
            slotOffset: params.offsets[idx],
        }));
        const instructionData = {
            slot: new anchor.BN(params.slot),
            submissions: submissions.map((x) => {
                x.signature = Buffer.from(x.signature, "base64");
                return x;
            }),
        };
        const accounts = {
            feed: this.pubkey,
            queue: queue,
            programState: State.keyFromSeed(program),
            recentSlothashes: SLOT_HASHES_SYSVAR_ID,
            payer: payerPublicKey,
            systemProgram: SystemProgram.programId,
            rewardVault: spl.getAssociatedTokenAddressSync(spl.NATIVE_MINT, queue),
            tokenProgram: spl.TOKEN_PROGRAM_ID,
            tokenMint: spl.NATIVE_MINT,
        };
        const remainingAccounts = [
            ...oracles.map((k) => ({
                pubkey: k,
                isSigner: false,
                isWritable: false,
            })),
            ...oracleFeedStats.map((k) => ({
                pubkey: k,
                isSigner: false,
                isWritable: true,
            })),
        ];
        const ix = program.instruction.pullFeedSubmitResponse(instructionData, {
            accounts,
            remainingAccounts,
        });
        return ix;
    }
    async isInitializedAsync() {
        return !(await checkNeedsInit(this.program.provider.connection, this.program.programId, this.pubkey));
    }
    async loadData() {
        return await this.program.account["pullFeedAccountData"].fetch(this.pubkey);
    }
    async loadValues() {
        const data = await this.loadData();
        return data.submissions
            .filter((x) => !x.oracle.equals(PublicKey.default))
            .map((x) => {
            Big.DP = 40;
            return {
                value: new Big(x.value.toString()).div(1e18),
                slot: new Big(x.slot.toString()),
                oracle: x.oracle,
            };
        });
    }
    async loadObservedValue(onlyAfter) {
        const values = await this.loadValues();
        return toFeedValue(values, onlyAfter);
    }
    async subscribeToValueChanges(callback) {
        const coder = new BorshAccountsCoder(this.program.idl);
        const subscriptionId = this.program.provider.connection.onAccountChange(this.pubkey, async (accountInfo, context) => {
            const feed = coder.decode("pullFeedAccountData", accountInfo.data);
            await callback(feed.submissions
                .filter((x) => !x.oracle.equals(PublicKey.default))
                .map((x) => {
                Big.DP = 40;
                return {
                    value: new Big(x.value.toString()).div(1e18),
                    slot: new anchor.BN(x.slot.toString()),
                    oracle: new PublicKey(x.oracle),
                };
            }));
        }, "processed");
        return subscriptionId;
    }
    static async subscribeToAllUpdates(program, callback) {
        const coder = new BorshAccountsCoder(program.idl);
        const subscriptionId = program.provider.connection.onProgramAccountChange(program.programId, async (keyedAccountInfo, ctx) => {
            const { accountId, accountInfo } = keyedAccountInfo;
            try {
                const feed = coder.decode("pullFeedAccountData", accountInfo.data);
                await callback([
                    ctx.slot,
                    {
                        pubkey: accountId,
                        submissions: feed.submissions
                            .filter((x) => !x.oracle.equals(PublicKey.default))
                            .map((x) => {
                            Big.DP = 40;
                            return {
                                value: new Big(x.value.toString()).div(1e18),
                                slot: new anchor.BN(x.slot.toString()),
                                oracle: new PublicKey(x.oracle),
                            };
                        }),
                    },
                ]);
            }
            catch (e) {
                console.log(`ParseFailure: ${e}`);
            }
        }, "processed", [
            {
                memcmp: {
                    bytes: "ZoV7s83c7bd",
                    offset: 0,
                },
            },
        ]);
        return subscriptionId;
    }
    lookupTableKey(data) {
        const lutSigner = PublicKey.findProgramAddressSync([Buffer.from("LutSigner"), this.pubkey.toBuffer()], this.program.programId)[0];
        const [_, lutKey] = AddressLookupTableProgram.createLookupTable({
            authority: lutSigner,
            payer: PublicKey.default,
            recentSlot: data.lutSlot,
        });
        return lutKey;
    }
    async loadLookupTable() {
        const data = await this.loadData();
        const lutKey = this.lookupTableKey(data);
        const accnt = await this.program.provider.connection.getAddressLookupTable(lutKey);
        return accnt.value;
    }
}
//# sourceMappingURL=pullFeed.js.map