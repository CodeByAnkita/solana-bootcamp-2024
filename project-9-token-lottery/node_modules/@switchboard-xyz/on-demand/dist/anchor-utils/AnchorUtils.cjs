"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnchorUtils = void 0;
const constants_js_1 = require("./../constants.cjs");
const anchor = __importStar(require("@coral-xyz/anchor"));
const web3_js_1 = require("@solana/web3.js");
const fs = __importStar(require("fs"));
const js_yaml_1 = __importDefault(require("js-yaml"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
class AnchorUtils {
    static async initWalletFromFile(filePath) {
        const keypair = await AnchorUtils.initKeypairFromFile(filePath);
        const wallet = new anchor.Wallet(keypair);
        return [wallet, keypair];
    }
    static async initKeypairFromFile(filePath) {
        const secretKeyString = fs.readFileSync(filePath, { encoding: "utf8" });
        const secretKey = Uint8Array.from(JSON.parse(secretKeyString));
        const keypair = web3_js_1.Keypair.fromSecretKey(secretKey);
        return keypair;
    }
    static async loadProgramFromEnv() {
        const config = await AnchorUtils.loadEnv();
        const idl = (await anchor.Program.fetchIdl(constants_js_1.SB_ON_DEMAND_PID, config.provider));
        const program = new anchor.Program(idl, config.provider);
        return new anchor.Program(idl, config.provider);
    }
    static async loadEnv() {
        const configPath = path_1.default.join(os_1.default.homedir(), ".config", "solana", "cli", "config.yml");
        const fileContents = fs.readFileSync(configPath, "utf8");
        const data = js_yaml_1.default.load(fileContents);
        const defaultCon = new web3_js_1.Connection("https://api.devnet.solana.com");
        const defaultKeypair = web3_js_1.Keypair.generate();
        const config = {
            rpcUrl: data.json_rpc_url,
            webSocketUrl: data.websocket_url,
            keypairPath: data.keypair_path,
            commitment: data.commitment,
            keypair: data.keypair_path,
            connection: defaultCon,
            provider: new anchor.AnchorProvider(defaultCon, new anchor.Wallet(defaultKeypair), {}),
            wallet: new anchor.Wallet(defaultKeypair),
            program: null,
        };
        config.keypair = (await AnchorUtils.initWalletFromFile(config.keypairPath))[1];
        config.connection = new web3_js_1.Connection(config.rpcUrl, {
            commitment: "confirmed",
        });
        config.wallet = new anchor.Wallet(config.keypair);
        config.provider = new anchor.AnchorProvider(config.connection, config.wallet, {
            preflightCommitment: "confirmed",
            commitment: "confirmed",
        });
        const idl = (await anchor.Program.fetchIdl(constants_js_1.SB_ON_DEMAND_PID, config.provider));
        const program = new anchor.Program(idl, config.provider);
        config.program = program;
        return config;
    }
    static loggedEvents(program, logs) {
        const coder = new anchor.BorshEventCoder(program.idl);
        const out = [];
        logs.forEach((log) => {
            if (log.startsWith("Program data: ")) {
                const strings = log.split(" ");
                if (strings.length !== 3)
                    return;
                try {
                    out.push(coder.decode(strings[2]));
                }
                catch { }
            }
        });
        return out;
    }
}
exports.AnchorUtils = AnchorUtils;
//# sourceMappingURL=AnchorUtils.js.map